// Generated by CoffeeScript 1.9.1
(function() {
  var Promise, _, check_config, cloc, content_template, destination, docco_styles, docco_template, dox, dox_template, ensure_directory, exec, ext, file_exists, fs, generate_content, generate_documentation, generate_readme, generate_source_html, get_language, gravatar, highlight, highlight_end, highlight_start, jade, l, languages, marked, parse, parse_args, parse_markdown, parse_markdown_from_file, path, ref, relative_base, spawn, walk, write_file;

  generate_documentation = function(source, context, callback) {
    return fs.readFile(source, "utf-8", function(error, code) {
      var sections;
      if (error) {
        throw error;
      }
      sections = parse(source, code);
      return highlight(source, sections, function() {
        generate_source_html(source, context, sections);
        return callback();
      });
    });
  };

  parse = function(source, code) {
    var code_text, docs_text, error, has_code, in_multi, j, language, len, line, lines, multi_accum, parsed, save, sections;
    lines = code.split('\n');
    sections = [];
    language = get_language(source);
    has_code = docs_text = code_text = '';
    in_multi = false;
    multi_accum = "";
    save = function(docs, code) {
      return sections.push({
        docs_text: docs,
        code_text: code
      });
    };
    for (j = 0, len = lines.length; j < len; j++) {
      line = lines[j];
      if (line.match(language.multi_start_matcher) || in_multi) {
        if (has_code) {
          save(docs_text, code_text);
          has_code = docs_text = code_text = '';
        }
        in_multi = true;
        multi_accum += line + '\n';
        if (line.match(language.multi_end_matcher)) {
          in_multi = false;
          try {
            parsed = dox.parseComments(multi_accum)[0];
            docs_text += dox_template(parsed);
          } catch (_error) {
            error = _error;
            console.log("Error parsing comments with Dox: " + error);
            docs_text = multi_accum;
          }
          multi_accum = '';
        }
      } else if (line.match(language.comment_matcher) && !line.match(language.comment_filter)) {
        if (has_code) {
          save(docs_text, code_text);
          has_code = docs_text = code_text = '';
        }
        docs_text += line.replace(language.comment_matcher, '') + '\n';
      } else {
        has_code = true;
        code_text += line + '\n';
      }
    }
    save(docs_text, code_text);
    return sections;
  };

  highlight = function(source, sections, callback) {
    var language, output, pygments, section;
    language = get_language(source);
    pygments = spawn('pygmentize', ['-l', language.name, '-f', 'html', '-O', 'encoding=utf-8,tabsize=2']);
    output = '';
    pygments.stderr.addListener('data', function(error) {
      if (error) {
        return console.error(error.toString());
      }
    });
    pygments.stdin.addListener('error', function(error) {
      console.error("Could not use Pygments to highlight the source.");
      return process.exit(1);
    });
    pygments.stdout.addListener('data', function(result) {
      if (result) {
        return output += result;
      }
    });
    pygments.addListener('exit', function() {
      var fragments;
      output = output.replace(highlight_start, '').replace(highlight_end, '');
      fragments = output.split(language.divider_html);
      return Promise.each(sections, function(section, i) {
        section.code_html = highlight_start + fragments[i] + highlight_end;
        return parse_markdown(section.docs_text).then(function(docs_html) {
          return section.docs_html = docs_html;
        });
      }).then(callback);
    });
    if (pygments.stdin.writable) {
      pygments.stdin.write(((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = sections.length; j < len; j++) {
          section = sections[j];
          results.push(section.code_text);
        }
        return results;
      })()).join(language.divider_text));
      return pygments.stdin.end();
    }
  };

  generate_source_html = function(source, context, sections) {
    var dest, html, title;
    title = path.basename(source);
    dest = destination(source, context);
    html = docco_template({
      title: title,
      file_path: source,
      sections: sections,
      context: context,
      path: path,
      relative_base: relative_base
    });
    console.log("docco: " + source + " -> " + dest);
    return write_file(dest, html);
  };

  generate_readme = function(context, sources, package_json) {
    var content_index_path, dest, readme_path, readme_template, source, title;
    title = "README";
    dest = context.config.output_dir + "/index.html";
    source = "README.md";
    readme_template = jade.compile(fs.readFileSync(__dirname + '/../resources/readme.jade').toString(), {
      filename: __dirname + '/../resources/readme.jade'
    });
    readme_path = (process.cwd()) + "/" + source;
    content_index_path = (process.cwd()) + "/" + context.config.content_dir + "/content_index.md";
    return Promise.props({
      content_index: parse_markdown_from_file(content_index_path),
      content: parse_markdown_from_file(readme_path, "There is no " + source + " for this project yet :(")
    }).then(function(result) {
      return cloc(sources.join(" "), function(code_stats) {
        var html;
        html = readme_template({
          title: title,
          context: context,
          content: result.content,
          content_index: result.content_index,
          file_path: source,
          path: path,
          relative_base: relative_base,
          package_json: package_json,
          code_stats: code_stats,
          gravatar: gravatar
        });
        console.log("docco: " + source + " -> " + dest);
        return write_file(dest, html);
      });
    });
  };

  generate_content = function(context, dir) {
    var walker;
    walker = walk.walk(dir, {
      followLinks: false
    });
    return walker.on('file', function(root, fileStats, next) {
      var dest, src;
      if (fileStats.name.match(new RegExp(".md$"))) {
        src = root + "/" + fileStats.name;
        dest = destination(src.replace(context.config.content_dir, ""), context);
        console.log("markdown: " + src + " --> " + dest);
        return parse_markdown_from_file(src).then(function(html) {
          html = content_template({
            title: fileStats.name,
            context: context,
            content: html,
            file_path: fileStats.name,
            path: path,
            relative_base: relative_base
          });
          return write_file(dest, html);
        })["finally"](next);
      }
    });
  };

  write_file = function(dest, contents) {
    var target_dir, write_func;
    target_dir = path.dirname(dest);
    write_func = function() {
      return fs.writeFile(dest, contents, function(err) {
        if (err) {
          throw err;
        }
      });
    };
    return fs.stat(target_dir, function(err, stats) {
      if (err && err.code !== 'ENOENT') {
        throw err;
      }
      if (!err) {
        return write_func();
      }
      if (err) {
        return exec("mkdir -p " + target_dir, function(err) {
          if (err) {
            throw err;
          }
          return write_func();
        });
      }
    });
  };

  parse_markdown_from_file = function(src, def) {
    if (def == null) {
      def = "";
    }
    return new Promise(function(resolve, reject) {
      var content;
      if (file_exists(src)) {
        content = fs.readFileSync(src).toString();
        return parse_markdown(content).then(resolve);
      } else {
        return resolve(def);
      }
    });
  };

  parse_markdown = function(content) {
    return new Promise(function(resolve, reject) {
      return marked(content, function(err, data) {
        if (err != null) {
          return reject(err);
        }
        return resolve(data);
      });
    });
  };

  cloc = function(paths, callback) {
    return exec("'" + __dirname + "/../vendor/cloc.pl' --quiet --read-lang-def='" + __dirname + "/../resources/cloc_definitions.txt' " + paths, function(err, stdout) {
      if (err) {
        console.log("Calculating project stats failed " + err);
      }
      return callback(stdout);
    });
  };

  fs = require('fs');

  path = require('path');

  jade = require('jade');

  dox = require('dox');

  gravatar = require('gravatar');

  Promise = require('bluebird');

  marked = require('marked');

  _ = require('underscore');

  walk = require('walk');

  ref = require('child_process'), spawn = ref.spawn, exec = ref.exec;

  languages = {
    '.coffee': {
      name: 'coffee-script',
      symbol: '#'
    },
    '.js': {
      name: 'javascript',
      symbol: '//',
      multi_start: "/*",
      multi_end: "*/"
    },
    '.rb': {
      name: 'ruby',
      symbol: '#'
    },
    '.py': {
      name: 'python',
      symbol: '#'
    },
    '.java': {
      name: 'java',
      symbol: '//',
      multi_start: "/*",
      multi_end: "*/"
    }
  };

  for (ext in languages) {
    l = languages[ext];
    l.comment_matcher = new RegExp('^\\s*' + l.symbol + '\\s?');
    l.comment_filter = new RegExp('(^#![/]|^\\s*#\\{)');
    l.divider_text = '\n' + l.symbol + 'DIVIDER\n';
    l.divider_html = new RegExp('\\n*<span class="c1?">' + l.symbol + 'DIVIDER<\\/span>\\n*');
    if (l.multi_start === "/*") {
      l.multi_start_matcher = new RegExp(/^[\s]*\/\*[.]*/);
    } else {
      l.multi_start_matcher = new RegExp(/a^/);
    }
    if (l.multi_end === "*/") {
      l.multi_end_matcher = new RegExp(/.*\*\/.*/);
    } else {
      l.multi_end_matcher = new RegExp(/a^/);
    }
  }

  get_language = function(source) {
    return languages[path.extname(source)];
  };

  relative_base = function(filepath, context) {
    var result;
    result = path.dirname(filepath) + '/';
    if (result === '/' || result === '//') {
      return '';
    } else {
      return result;
    }
  };

  destination = function(filepath, context) {
    var base_path;
    base_path = relative_base(filepath, context);
    return (context.config.output_dir + "/") + filepath + '.html';
  };

  ensure_directory = function(dir, callback) {
    return exec("mkdir -p " + dir, function() {
      return callback();
    });
  };

  file_exists = function(path) {
    var ex;
    try {
      return fs.lstatSync(path).isFile;
    } catch (_error) {
      ex = _error;
      return false;
    }
  };

  docco_template = jade.compile(fs.readFileSync(__dirname + '/../resources/docco.jade').toString(), {
    filename: __dirname + '/../resources/docco.jade'
  });

  dox_template = jade.compile(fs.readFileSync(__dirname + '/../resources/dox.jade').toString(), {
    filename: __dirname + '/../resources/dox.jade'
  });

  content_template = jade.compile(fs.readFileSync(__dirname + '/../resources/content.jade').toString(), {
    filename: __dirname + '/../resources/content.jade'
  });

  docco_styles = fs.readFileSync(__dirname + '/../resources/docco.css').toString();

  highlight_start = '<div class="highlight"><pre>';

  highlight_end = '</pre></div>';

  parse_args = function(callback) {
    var a, args, lang_filter, project_name, roots;
    args = process.ARGV;
    project_name = "";
    if (args[0] === "-name") {
      args.shift();
      project_name = args.shift();
    }
    args = args.sort();
    if (!args.length) {
      return;
    }
    roots = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = args.length; j < len; j++) {
        a = args[j];
        results.push(a.replace(/\/+$/, ''));
      }
      return results;
    })();
    roots = roots.join(" ");
    lang_filter = (function() {
      var results;
      results = [];
      for (ext in languages) {
        results.push(" -name '*" + ext + "' ");
      }
      return results;
    })();
    lang_filter = lang_filter.join(' -o ');
    return exec("find " + roots + " -type f \\( " + lang_filter + " \\)", function(err, stdout) {
      var sources;
      if (err) {
        throw err;
      }
      sources = stdout.split("\n").filter(function(file) {
        return file !== '' && path.basename(file)[0] !== '.';
      });
      console.log("docco: Recursively generating documentation for " + roots);
      return callback(sources, project_name, args);
    });
  };

  check_config = function(context, pkg) {
    var defaults;
    defaults = {
      css: __dirname + '/../resources/docco.css',
      show_timestamp: true,
      output_dir: "docs",
      project_name: context.options.project_name || '',
      content_dir: null
    };
    return context.config = _.extend(defaults, pkg.docco_husky || {});
  };

  parse_args(function(sources, project_name, raw_paths) {
    var context, err, package_json, package_path;
    context = {
      sources: sources,
      options: {
        project_name: project_name
      }
    };
    package_path = process.cwd() + '/package.json';
    try {
      package_json = file_exists(package_path) ? JSON.parse(fs.readFileSync(package_path).toString()) : {};
    } catch (_error) {
      err = _error;
      console.log("Error parsing package.json");
      console.log(err);
    }
    check_config(context, package_json);
    return ensure_directory(context.config.output_dir, function() {
      var files, next_file;
      generate_readme(context, raw_paths, package_json);
      fs.writeFile(context.config.output_dir + "/docco.css", fs.readFileSync(context.config.css).toString());
      files = sources.slice(0, +sources.length + 1 || 9e9);
      next_file = function() {
        if (files.length) {
          return generate_documentation(files.shift(), context, next_file);
        }
      };
      next_file();
      if (context.config.content_dir) {
        return generate_content(context, context.config.content_dir);
      }
    });
  });

}).call(this);
